"""
Client for managing MCP servers and sessions.

This module provides a high-level client that manages MCP servers, connectors,
and sessions from configuration.
"""

import json
import time
from typing import Any

from .config import create_connector_from_config, load_config_file
from .logging import logger
from .session import MCPSession


class MCPClient:
    """Client for managing MCP servers and sessions.

    This class provides a unified interface for working with MCP servers,
    handling configuration, connector creation, and session management.
    """

    def __init__(
        self,
        config: str | dict[str, Any] | None = None,
        verbose: bool = False,
    ) -> None:
        """Initialize a new MCP client.

        Args:
            config: Either a dict containing configuration or a path to a JSON config file.
                   If None, an empty configuration is used.
            verbose: Whether to enable verbose logging for this client.
        """
        self.config: dict[str, Any] = {}
        self.sessions: dict[str, MCPSession] = {}
        self.active_sessions: list[str] = []
        self.verbose = verbose
        self.request_counter = 0
        self.start_time = time.time()

        # Load configuration if provided
        if config is not None:
            if isinstance(config, str):
                logger.info(f"üîÑ ‰ªéÈÖçÁΩÆÊñá‰ª∂Âä†ËΩΩMCPÂÆ¢Êà∑Á´Ø: {config}")
                self.config = load_config_file(config)
                if self.verbose:
                    logger.info(f"üìÑ ÈÖçÁΩÆËØ¶ÊÉÖ: {json.dumps(self.config, ensure_ascii=False, indent=2)}")
            else:
                logger.info("üîÑ ‰ªéÂ≠óÂÖ∏Âä†ËΩΩMCPÂÆ¢Êà∑Á´ØÈÖçÁΩÆ")
                self.config = config
                if self.verbose:
                    logger.info(f"üìÑ ÈÖçÁΩÆËØ¶ÊÉÖ: {json.dumps(self.config, ensure_ascii=False, indent=2)}")
            
            # ÊâìÂç∞Â∑≤ÈÖçÁΩÆÁöÑÊúçÂä°Âô®
            servers = self.config.get("mcpServers", {})
            logger.info(f"‚ÑπÔ∏è Â∑≤ÈÖçÁΩÆ {len(servers)} ‰∏™MCPÊúçÂä°Âô®: {', '.join(servers.keys())}")

    @classmethod
    def from_dict(cls, config: dict[str, Any], verbose: bool = False) -> "MCPClient":
        """Create a MCPClient from a dictionary.

        Args:
            config: The configuration dictionary.
            verbose: Whether to enable verbose logging.
        """
        logger.info("üîÑ ‰ªéÂ≠óÂÖ∏ÂàõÂª∫MCPClientÂÆû‰æã")
        return cls(config=config, verbose=verbose)

    @classmethod
    def from_config_file(cls, filepath: str, verbose: bool = False) -> "MCPClient":
        """Create a MCPClient from a configuration file.

        Args:
            filepath: The path to the configuration file.
            verbose: Whether to enable verbose logging.
        """
        logger.info(f"üîÑ ‰ªéÈÖçÁΩÆÊñá‰ª∂ÂàõÂª∫MCPClientÂÆû‰æã: {filepath}")
        return cls(config=load_config_file(filepath), verbose=verbose)

    def add_server(
        self,
        name: str,
        server_config: dict[str, Any],
    ) -> None:
        """Add a server configuration.

        Args:
            name: The name to identify this server.
            server_config: The server configuration.
        """
        logger.info(f"‚ûï Ê∑ªÂä†ÊúçÂä°Âô®ÈÖçÁΩÆ: {name}")
        if self.verbose:
            logger.info(f"üìÑ ÊúçÂä°Âô®ÈÖçÁΩÆËØ¶ÊÉÖ: {json.dumps(server_config, ensure_ascii=False, indent=2)}")
            
        if "mcpServers" not in self.config:
            self.config["mcpServers"] = {}

        self.config["mcpServers"][name] = server_config

    def remove_server(self, name: str) -> None:
        """Remove a server configuration.

        Args:
            name: The name of the server to remove.
        """
        logger.info(f"‚ûñ ÁßªÈô§ÊúçÂä°Âô®ÈÖçÁΩÆ: {name}")
        if "mcpServers" in self.config and name in self.config["mcpServers"]:
            del self.config["mcpServers"][name]

            # If we removed an active session, remove it from active_sessions
            if name in self.active_sessions:
                self.active_sessions.remove(name)
                logger.info(f"‚ÑπÔ∏è Â∑≤‰ªéÊ¥ªÂä®‰ºöËØùÂàóË°®‰∏≠ÁßªÈô§ {name}")

    def get_server_names(self) -> list[str]:
        """Get the list of configured server names.

        Returns:
            List of server names.
        """
        servers = list(self.config.get("mcpServers", {}).keys())
        logger.info(f"‚ÑπÔ∏è Â∑≤ÈÖçÁΩÆÁöÑÊúçÂä°Âô®: {', '.join(servers)}")
        return servers

    def save_config(self, filepath: str) -> None:
        """Save the current configuration to a file.

        Args:
            filepath: The path to save the configuration to.
        """
        logger.info(f"üíæ ‰øùÂ≠òÈÖçÁΩÆÂà∞Êñá‰ª∂: {filepath}")
        with open(filepath, "w") as f:
            json.dump(self.config, f, indent=2)
        logger.info("‚úÖ ÈÖçÁΩÆÂ∑≤‰øùÂ≠ò")

    async def create_session(self, server_name: str, auto_initialize: bool = True) -> MCPSession:
        """Create a session for the specified server.

        Args:
            server_name: The name of the server to create a session for.

        Returns:
            The created MCPSession.

        Raises:
            ValueError: If no servers are configured or the specified server doesn't exist.
        """
        logger.info(f"üîå ÂàõÂª∫ {server_name} ÁöÑ‰ºöËØù")
        start_time = time.time()
        
        # Get server config
        servers = self.config.get("mcpServers", {})
        if not servers:
            logger.error("‚ùå ÈÖçÁΩÆ‰∏≠Êú™ÂÆö‰πâMCPÊúçÂä°Âô®")
            raise ValueError("No MCP servers defined in config")

        if server_name not in servers:
            logger.error(f"‚ùå ÈÖçÁΩÆ‰∏≠Êú™ÊâæÂà∞ÊúçÂä°Âô® '{server_name}'")
            raise ValueError(f"Server '{server_name}' not found in config")

        server_config = servers[server_name]
        if self.verbose:
            logger.info(f"üìÑ ÊúçÂä°Âô® {server_name} ÈÖçÁΩÆ: {json.dumps(server_config, ensure_ascii=False, indent=2)}")
            
        logger.info(f"üîÑ Ê≠£Âú®‰∏∫ {server_name} ÂàõÂª∫ËøûÊé•Âô®")
        connector = create_connector_from_config(server_config)

        # Create the session
        logger.info(f"üîÑ Ê≠£Âú®‰∏∫ {server_name} ÂàõÂª∫‰ºöËØù")
        session = MCPSession(connector)
        if auto_initialize:
            logger.info(f"üîÑ Ê≠£Âú®ÂàùÂßãÂåñ {server_name} ‰ºöËØù")
            await session.initialize()
            logger.info(f"‚úÖ {server_name} ‰ºöËØùÂàùÂßãÂåñÂÆåÊàê")
        self.sessions[server_name] = session

        # Add to active sessions
        if server_name not in self.active_sessions:
            self.active_sessions.append(server_name)
            logger.info(f"‚ûï Â∑≤Â∞Ü {server_name} Ê∑ªÂä†Âà∞Ê¥ªÂä®‰ºöËØùÂàóË°®")

        elapsed = time.time() - start_time
        logger.info(f"‚è±Ô∏è ÂàõÂª∫‰ºöËØùËÄóÊó∂: {elapsed:.2f}Áßí")
        return session

    async def create_all_sessions(
        self,
        auto_initialize: bool = True,
    ) -> dict[str, MCPSession]:
        """Create a session for the specified server.

        Args:
            auto_initialize: Whether to automatically initialize the session.

        Returns:
            The created MCPSession. If server_name is None, returns the first created session.

        Raises:
            ValueError: If no servers are configured or the specified server doesn't exist.
        """
        logger.info("üîÑ ÂàõÂª∫ÊâÄÊúâÊúçÂä°Âô®ÁöÑ‰ºöËØù")
        start_time = time.time()
        
        # Get server config
        servers = self.config.get("mcpServers", {})
        if not servers:
            logger.error("‚ùå ÈÖçÁΩÆ‰∏≠Êú™ÂÆö‰πâMCPÊúçÂä°Âô®")
            raise ValueError("No MCP servers defined in config")

        # Create sessions for all servers
        for name in servers:
            logger.info(f"üîÑ ÂàõÂª∫ {name} ÁöÑ‰ºöËØù")
            session = await self.create_session(name, auto_initialize)
            if auto_initialize:
                logger.info(f"‚úÖ {name} ‰ºöËØùÂàùÂßãÂåñÂÆåÊàê")

        elapsed = time.time() - start_time
        logger.info(f"‚è±Ô∏è ÂàõÂª∫ÊâÄÊúâ‰ºöËØùËÄóÊó∂: {elapsed:.2f}Áßí")
        logger.info(f"‚úÖ ÂÖ±ÂàõÂª∫‰∫Ü {len(servers)} ‰∏™‰ºöËØù")
        return self.sessions

    def get_session(self, server_name: str) -> MCPSession:
        """Get an existing session.

        Args:
            server_name: The name of the server to get the session for.
                        If None, uses the first active session.

        Returns:
            The MCPSession for the specified server.

        Raises:
            ValueError: If no active sessions exist or the specified session doesn't exist.
        """
        if server_name not in self.sessions:
            logger.error(f"‚ùå ÊúçÂä°Âô® '{server_name}' ‰∏çÂ≠òÂú®‰ºöËØù")
            raise ValueError(f"No session exists for server '{server_name}'")

        logger.info(f"‚ÑπÔ∏è Ëé∑Âèñ {server_name} ÁöÑ‰ºöËØù")
        return self.sessions[server_name]

    def get_all_active_sessions(self) -> dict[str, MCPSession]:
        """Get all active sessions.

        Returns:
            Dictionary mapping server names to their MCPSession instances.
        """
        active_sessions = {name: self.sessions[name] for name in self.active_sessions if name in self.sessions}
        logger.info(f"‚ÑπÔ∏è Ëé∑ÂèñÊâÄÊúâÊ¥ªÂä®‰ºöËØùÔºåÂÖ± {len(active_sessions)} ‰∏™: {', '.join(active_sessions.keys())}")
        return active_sessions

    async def close_session(self, server_name: str) -> None:
        """Close a session.

        Args:
            server_name: The name of the server to close the session for.
                        If None, uses the first active session.

        Raises:
            ValueError: If no active sessions exist or the specified session doesn't exist.
        """
        # Check if the session exists
        if server_name not in self.sessions:
            logger.warning(f"‚ö†Ô∏è ÊúçÂä°Âô® '{server_name}' ‰∏çÂ≠òÂú®‰ºöËØùÔºåÊó†ÈúÄÂÖ≥Èó≠")
            return

        logger.info(f"üîå Ê≠£Âú®ÂÖ≥Èó≠ {server_name} ÁöÑ‰ºöËØù")
        start_time = time.time()
        
        # Get the session
        session = self.sessions[server_name]

        try:
            # Disconnect from the session
            logger.info(f"üîÑ Ê≠£Âú®Êñ≠ÂºÄ {server_name} ÁöÑËøûÊé•")
            await session.disconnect()
            logger.info(f"‚úÖ {server_name} Êñ≠ÂºÄËøûÊé•ÊàêÂäü")
        except Exception as e:
            logger.error(f"‚ùå ÂÖ≥Èó≠ {server_name} ‰ºöËØùÊó∂Âá∫Èîô: {e}")
        finally:
            # Remove the session regardless of whether disconnect succeeded
            del self.sessions[server_name]
            logger.info(f"üóëÔ∏è Â∑≤ÁßªÈô§ {server_name} ÁöÑ‰ºöËØùÂÆû‰æã")

            # Remove from active_sessions
            if server_name in self.active_sessions:
                self.active_sessions.remove(server_name)
                logger.info(f"‚ûñ Â∑≤‰ªéÊ¥ªÂä®‰ºöËØùÂàóË°®‰∏≠ÁßªÈô§ {server_name}")
            
            elapsed = time.time() - start_time
            logger.info(f"‚è±Ô∏è ÂÖ≥Èó≠‰ºöËØùËÄóÊó∂: {elapsed:.2f}Áßí")

    async def close_all_sessions(self) -> None:
        """Close all active sessions.

        This method ensures all sessions are closed even if some fail.
        """
        logger.info("üîå Ê≠£Âú®ÂÖ≥Èó≠ÊâÄÊúâÊ¥ªÂä®‰ºöËØù")
        start_time = time.time()
        
        # Get a list of all session names first to avoid modification during iteration
        server_names = list(self.sessions.keys())
        errors = []

        for server_name in server_names:
            try:
                logger.info(f"üîÑ Ê≠£Âú®ÂÖ≥Èó≠ {server_name} ÁöÑ‰ºöËØù")
                await self.close_session(server_name)
                logger.info(f"‚úÖ {server_name} ‰ºöËØùÂ∑≤ÂÖ≥Èó≠")
            except Exception as e:
                error_msg = f"Failed to close session for server '{server_name}': {e}"
                logger.error(f"‚ùå {error_msg}")
                errors.append(error_msg)

        # Log summary if there were errors
        if errors:
            logger.error(f"‚ùå ÂÖ≥Èó≠‰ºöËØùÊó∂ÈÅáÂà∞ {len(errors)} ‰∏™ÈîôËØØ")
        else:
            elapsed = time.time() - start_time
            logger.info(f"‚è±Ô∏è ÂÖ≥Èó≠ÊâÄÊúâ‰ºöËØùËÄóÊó∂: {elapsed:.2f}Áßí")
            logger.info("‚úÖ ÊâÄÊúâ‰ºöËØùÂ∑≤ÊàêÂäüÂÖ≥Èó≠")
            
        # ËÆ∞ÂΩïÂÆ¢Êà∑Á´Ø‰ΩøÁî®ÁªüËÆ°
        total_time = time.time() - self.start_time
        logger.info(f"üìä MCPÂÆ¢Êà∑Á´Ø‰ΩøÁî®ÁªüËÆ°:")
        logger.info(f"   - ÊÄªËøêË°åÊó∂Èó¥: {total_time:.2f}Áßí")
        logger.info(f"   - ËØ∑Ê±ÇËÆ°Êï∞: {self.request_counter}")
        if self.request_counter > 0:
            logger.info(f"   - Âπ≥ÂùáÊØè‰∏™ËØ∑Ê±ÇËÄóÊó∂: {total_time/self.request_counter:.2f}Áßí")
